class_name RoomManager extends Node

# --------- USED IN GRAPH GENERATION ---------

# The size of the grid generated by the RoomManager
const GRID_SIZE: int = 8;
# The random factor of the direct path generation from start to goal
const PATH_GENERATION_RANDOM_FACTOR: float = .5;
# The random factor of branching after path generation
const BRANCH_GENERATION_RANDOM_FACTOR: float = 0.2;
# The max branch length
const BRANCH_LENGTH: int = 3;
# coordinates of START room.
const START_I = GRID_SIZE - 1;
const START_J = 0;
# coordinate of END room
const END_I = 0;
const END_J =  GRID_SIZE - 1;
# rules for map generation / regeneration
const MAX_ROOM_COUNT = 20;
const MIN_ROOM_COUNT = 12;

# Stores whether the room is a START, GOAL STATE, or lowkey chill with it
enum ROOM_TYPE {START, GOAL, NEITHER};
# The adjacency list of the graph before making the map.
var node_graph = {};
# The grid used for generation.
var grid = [];

# ROOM resource.
const ROOM = preload("uid://nwhqrixlnb1d");

# ------- ROOM GENERATION HELPER FUNCTIONS ---------

# Makes a GRID_SIZE x GRID_SIZE grid for graph initialization.
func generate_grid() -> void:
	for i in range(GRID_SIZE):
		grid.append([])
		for j in range(GRID_SIZE):
			grid[i].append(ROOM_TYPE.NEITHER);
	
	# Start is always top-left
	grid[START_I][START_J] = ROOM_TYPE.START;
	
	# top right goal state
	grid[0][GRID_SIZE - 1] = ROOM_TYPE.GOAL;

# Helper for grid conversion to graph for initializing valid rooms.
func _get_neighbors(i: int, j: int) -> Array:
	var neighbors: Array = []
	if i > 0:
		neighbors.append(Vector2i(i - 1, j))
	if i < GRID_SIZE - 1:
		neighbors.append(Vector2i(i + 1, j))
	if j > 0:
		neighbors.append(Vector2i(i, j - 1))
	if j < GRID_SIZE - 1:
		neighbors.append(Vector2i(i, j + 1))
	return neighbors

# returns a subset of an array containing at least one element given an rng factor
func _random_subarray_at_least_one(arr: Array, skip_chance: float) -> Array:
	var res = []
	for elem in arr:
		if randf() > skip_chance:
			res.append(elem)
	if res.is_empty():
		res.append(arr[randi() % arr.size()])
	return res
			
# Create the graph (array of Rooms, storing neighbors inside).
func grid_to_graph() -> void:
	node_graph.clear()
	for i in GRID_SIZE:
		for j in GRID_SIZE:
			node_graph[Vector2i(i, j)] = _get_neighbors(i, j)

# BFS direct path generation with randomization
func generate_direct_path(goal) -> Array:
	var start = Vector2i(START_I, START_J);
	var queue: Array = [start];
	var path_mappings: Dictionary = {start: null};
	var visited: Array = [start];
	
	while !queue.is_empty() and (!visited.has(goal)):
		var current = queue.pop_front();
		var children = _random_subarray_at_least_one(node_graph[current], PATH_GENERATION_RANDOM_FACTOR);
		# EDGE CASE: next to goal_state, but never reaches it
		if (node_graph[current].has(goal)) and (not children.has(goal)): children.append(goal);
		for node in children:
			if not visited.has(node):
				visited.append(node);
				path_mappings[node] = current;
				queue.append(node);
	
	if not path_mappings.has(goal):
		# goal couldnt be found
		return [];
	
	# get path
	var path = [goal];
	var prev = path_mappings.get(goal);
	while (prev != null):
		path.push_front(prev);
		prev = path_mappings.get(prev);
		
	return path;

# add branches to a preexisting path
func branch_path(path: Array) -> void:
	const MAX_ATTEMPT_BRANCH = 25;
	for node in path:
		if randf() < BRANCH_GENERATION_RANDOM_FACTOR:
			var successful_branches = 0;
			var attempts = 0;
			var last_branch_coord : Vector2i = node;
			while (attempts < MAX_ATTEMPT_BRANCH) and (successful_branches < BRANCH_LENGTH):
				var neighbors = _get_neighbors(last_branch_coord.x, last_branch_coord.y);
				# randomly choose a node not in the path
				var chosen = neighbors[randi() % len(neighbors)];
				if path.has(chosen):
					attempts += 1;
					continue;
				else:
					successful_branches += 1;
					if not path.has(chosen): path.append(chosen);

# stores the final generated graph in the global rooms object
func path_to_rooms(path: Array) -> void:
	# for each node in the path, get all possible neighbors in the graph
	var adj_list : Dictionary = {};
	for node in path:
		var neighbors_grid = _get_neighbors(node.x, node.y)
		var neighbors_graph : Array = []
		# prune neighbors not in the path
		for child in neighbors_grid:
			if path.has(child): neighbors_graph.append(child)
		adj_list[node] = neighbors_graph;
		
	# make each node in the adj_list
	for node in adj_list.keys():
		# generate room objects
		var room = ROOM.instantiate();
		# each node knows the coordinates of its neighbors...
		room.neighbors = adj_list[node];
		room.room_coordinate = node;
		# the autoload maps the coordinate (node) to the room globally
		Global.rooms[node] = room;
		
	
# reset the entire script state
func reset_state():
	node_graph = {};
	grid = [];
	
func generate_path():
	reset_state();
	generate_grid();
	grid_to_graph();
	var path = generate_direct_path(Vector2i(END_I, END_J));
	while path.is_empty(): path = generate_direct_path(Vector2i(END_I, END_J));
	branch_path(path);
	path_to_rooms(path);
	return path

func _ready():
	# generate path given conditions
	var path = []
	while (len(path) > MAX_ROOM_COUNT) or (len(path) < MIN_ROOM_COUNT): path = generate_path()
	var goal = Vector2i(END_I, END_J);
	# DEBUG
	var hb: HBoxContainer = $"../HBoxContainer";
	if not hb: return
	# display generated path
	var columns = hb.get_children();
	for j in range(GRID_SIZE):
		var elements = columns[j].get_children();
		for i in range(GRID_SIZE): 
			if path.has(Vector2i(i, j)):
				elements[i].color = Color(0, 0, 0, 1);
			if Vector2i(i, j) == goal: elements[i].color = Color(0, 1, 0, 1);
			if Vector2i(i, j) == Vector2i(START_I, START_J): elements[i].color = Color(1, 0, 0, 1);
